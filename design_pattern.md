# 设计模式
- 观察者模式: 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
  - 被观察者
  - 观察者 -> implements Listener with EventObject with onPublishEvent method
  - 业务方法 publishEvent
  - 观察者与被观察者解耦，不需要强关联
  - 观察者同步/异步联动
- 工厂方法:定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。
  - 工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：
  - 工厂 + 产品: 工厂 + 抽象产品 ：隐藏了产品产生细节
  - 静态工厂方法: 即使工厂又是产品
- 抽象工厂方法：抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；
  - 抽象产品 抽象工厂
  - 供应商 实际产品
  - 先定义客户端
- 生成器模式
  - Builder模式是为了创建一个复杂的对象，需要多个步骤完成创建，或者需要多个零件组装的场景，且创建过程中可以灵活调用不同的步骤或组件。
  - 生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。
- 适配器模式：只约定输入与输出  变化多 灵活  220v 中国电视 需要在国外播放， 220v 出画面， 美国转换器/英国转换器/德国转换器    220v 出图像， support
  - A接口转换为B接口
  - Adapter implement B接口并且内部有持有A接口的类
  - A, B均为抽象接口
  - Callable 接口转Runnable 接口
- 装饰器模式： 核心功能与附加功能分离
- 策略模式: 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
  - 策略模式的核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。
  - 策略模式：Strategy，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。
    - 策略接口 -定义关键算法
    - 策略上下文 - 持有默认策略 支持策略设置 通过策略调用算法
    - 各种策略实现
- 回调函数模式
  - callback

